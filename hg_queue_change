#!/bin/bash

# Get all queues and filter out current active one.
QUEUES=`hg qqueue  | sed '/[^(]*([^)]*)/d'`
QUEUEARRAY=($QUEUES)

# Enumerate and display queue name on stdout
function queueEnumerate()
{
  local i=0
  for j in "${QUEUEARRAY[@]}"
  do
    echo -n "${i}. "
    echo $j
    let i+=1
  done
}

queueEnumerate

# Choice the queue you want to active.
echo -n "Select the queue you want to active: [1~"; echo "${#QUEUEARRAY[@]}] "
read SELECTED_QUEUE

# Validate input value
if [ `echo ${SELECTED_QUEUE} | sed 's/^[-+0-9][0-9]*//' | wc -c` -ne 1 ]; then
  echo "Is not a valid number!!"
  exit 0
elif [ ${SELECTED_QUEUE} -lt "0" ] || [ ${SELECTED_QUEUE} -gt ${#QUEUEARRAY[@]} ]; then
  echo "Is not a valid range!!"
  exit 0
fi

# Step 1: popup the current active one.
echo "Pop up all patch..."
hg qpop -a
if [ $? -ne 0 ]; then
  echo "Patch rotten. Refresh/Force pop up/Abort?[R/F/A]"
  read decision

  if [ ${decision} == "R" ] || [ ${decision} == "r" ]; then
    hg qrefresh
    hg qpop -a
  elif [ ${decision} == "F" ] || [ ${decision} == "f" ]; then
    hg qpop -a -f
  else
    echo "Abort..."
    exit $?
  fi
fi

# Step 2: active the selected queue.
hg qqueue ${QUEUEARRAY[SELECTED_QUEUE]}

# Step 3: pull & update
echo -n "hg pull -u before patch push?[y/n] "
read pullData
echo -n "${pullData}" > sed 's/.*/\L&/' > pullData
if [ ${pullData} == "y" ]; then
  hg pull -u
fi

# Step 4: push all patches.
hg qpush -a

echo "Done..."
